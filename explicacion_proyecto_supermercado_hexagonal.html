<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explicación del Proyecto de Simulación de Supermercado con Arquitectura Hexagonal</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #2980b9;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }
        h3 {
            color: #3498db;
        }
        code {
            background-color: #f8f8f8;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
        }
        pre {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            line-height: 1.4;
        }
        ul, ol {
            padding-left: 25px;
        }
        .diagram {
            font-family: monospace;
            white-space: pre;
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            line-height: 1.2;
        }
        .print-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 20px 0;
            cursor: pointer;
            border-radius: 5px;
        }
        @media print {
            .print-button {
                display: none;
            }
            body {
                font-size: 12pt;
            }
            h1 {
                font-size: 18pt;
            }
            h2 {
                font-size: 16pt;
            }
            h3 {
                font-size: 14pt;
            }
        }
    </style>
</head>
<body>
    <button class="print-button" onclick="window.print()">Imprimir como PDF</button>
    
    <h1>Explicación del Proyecto de Simulación de Supermercado con Arquitectura Hexagonal</h1>
    
    <h2>1. Introducción</h2>
    <p>Este documento explica el proyecto de simulación de supermercado implementado con arquitectura hexagonal (también conocida como arquitectura de puertos y adaptadores). El proyecto es una aplicación CRUD que gestiona las entidades principales de un supermercado, como productos, inventario, cajeros, clientes y ventas.</p>
    
    <h2>2. Arquitectura Hexagonal: Principios Fundamentales</h2>
    <p>La arquitectura hexagonal, propuesta por Alistair Cockburn, es un estilo arquitectónico que permite a una aplicación ser igualmente conducida por usuarios, programas, pruebas automatizadas o scripts por lotes, y ser desarrollada y probada de forma aislada de sus eventuales dispositivos y bases de datos en tiempo de ejecución.</p>
    
    <h3>Principios clave:</h3>
    <ol>
        <li><strong>Separación de Preocupaciones</strong>: Separa claramente la lógica de negocio de los detalles técnicos.</li>
        <li><strong>Independencia de Frameworks</strong>: El dominio no depende de frameworks externos.</li>
        <li><strong>Testabilidad</strong>: Facilita las pruebas unitarias al aislar el dominio.</li>
        <li><strong>Mantenibilidad</strong>: Cambios en la infraestructura no afectan al dominio.</li>
        <li><strong>Flexibilidad</strong>: Permite cambiar fácilmente las implementaciones de infraestructura.</li>
    </ol>
    
    <h3>Componentes principales:</h3>
    <ul>
        <li><strong>Dominio (Hexágono Interior)</strong>: Contiene las entidades de negocio y la lógica central.</li>
        <li><strong>Puertos</strong>: Interfaces que definen cómo el dominio interactúa con el exterior.
            <ul>
                <li><strong>Puertos Primarios (Input)</strong>: Definen servicios que el dominio ofrece.</li>
                <li><strong>Puertos Secundarios (Output)</strong>: Definen servicios que el dominio requiere.</li>
            </ul>
        </li>
        <li><strong>Adaptadores</strong>: Implementaciones concretas de los puertos.
            <ul>
                <li><strong>Adaptadores Primarios (Input)</strong>: Consumen los puertos primarios (ej. controladores REST).</li>
                <li><strong>Adaptadores Secundarios (Output)</strong>: Implementan los puertos secundarios (ej. repositorios).</li>
            </ul>
        </li>
    </ul>
    
    <h2>3. Implementación en el Proyecto de Supermercado</h2>
    
    <h3>Estructura del Proyecto</h3>
    <p>El proyecto está organizado en módulos Maven que reflejan la arquitectura hexagonal:</p>
    
    <ol>
        <li><strong>domain</strong>: Contiene el núcleo de la aplicación
            <ul>
                <li>Entidades de negocio (Producto, Cajero, Cliente, Inventario, Venta)</li>
                <li>Puertos de entrada y salida (interfaces)</li>
            </ul>
        </li>
        <li><strong>application</strong>: Implementa la lógica de aplicación
            <ul>
                <li>Servicios que implementan los puertos primarios</li>
                <li>Orquestación de casos de uso</li>
                <li>Implementación de CQRS (Command Query Responsibility Segregation)</li>
            </ul>
        </li>
        <li><strong>infrastructure</strong>: Contiene adaptadores secundarios
            <ul>
                <li>Implementaciones de repositorios</li>
                <li>Persistencia de datos</li>
                <li>Mapeo entre entidades de dominio y entidades de persistencia</li>
            </ul>
        </li>
        <li><strong>rest-api</strong>: Contiene adaptadores primarios
            <ul>
                <li>Controladores REST</li>
                <li>Configuración de Spring Boot</li>
                <li>Documentación de API (Swagger)</li>
            </ul>
        </li>
        <li><strong>cli</strong>: Interfaz de línea de comandos
            <ul>
                <li>Cliente que consume la API REST</li>
                <li>Interfaz de usuario basada en consola</li>
            </ul>
        </li>
        <li><strong>shared-dto</strong>: DTOs compartidos entre módulos
            <ul>
                <li>Objetos de transferencia de datos</li>
                <li>Comandos y consultas CQRS</li>
            </ul>
        </li>
    </ol>
    
    <h3>Flujo de Datos en la Arquitectura</h3>
    <ol>
        <li><strong>Solicitud Externa</strong>: Un cliente (navegador, CLI, etc.) envía una solicitud.</li>
        <li><strong>Adaptador Primario</strong>: Un controlador REST recibe la solicitud y la convierte en una llamada a un servicio de aplicación.</li>
        <li><strong>Puerto Primario</strong>: Define la interfaz que el adaptador primario utiliza para comunicarse con el dominio.</li>
        <li><strong>Servicio de Aplicación</strong>: Implementa el puerto primario y orquesta la lógica de negocio.</li>
        <li><strong>Entidades de Dominio</strong>: Contienen la lógica de negocio central.</li>
        <li><strong>Puerto Secundario</strong>: Define la interfaz que el dominio utiliza para comunicarse con servicios externos.</li>
        <li><strong>Adaptador Secundario</strong>: Implementa el puerto secundario para proporcionar servicios externos (como persistencia).</li>
        <li><strong>Infraestructura Externa</strong>: Base de datos, servicios externos, etc.</li>
    </ol>
    
    <h2>4. Componentes Principales del Proyecto</h2>
    
    <h3>Dominio</h3>
    <ul>
        <li><strong>Entidades</strong>: Clases como <code>Producto</code>, <code>Cajero</code>, <code>Cliente</code>, <code>Inventario</code> y <code>Venta</code> que representan los conceptos centrales del negocio.</li>
        <li><strong>Puertos de Entrada</strong>: Interfaces como <code>ServicioProductoPort</code> que definen las operaciones que la aplicación ofrece.</li>
        <li><strong>Puertos de Salida</strong>: Interfaces como <code>RepositorioProductoPort</code> que definen las operaciones que la aplicación requiere.</li>
    </ul>
    
    <h3>Aplicación</h3>
    <ul>
        <li><strong>Servicios</strong>: Clases como <code>ServicioProductoImpl</code> que implementan los puertos de entrada y orquestan la lógica de negocio.</li>
        <li><strong>Comandos y Consultas</strong>: Implementación del patrón CQRS con clases como <code>CreateProductCommand</code> y <code>GetProductByIdQuery</code>.</li>
        <li><strong>Manejadores</strong>: Clases como <code>CreateProductCommandHandler</code> que procesan comandos y consultas específicos.</li>
    </ul>
    
    <h3>Infraestructura</h3>
    <ul>
        <li><strong>Adaptadores de Repositorio</strong>: Clases como <code>AdaptadorRepositorioProducto</code> que implementan los puertos de salida.</li>
        <li><strong>Entidades JPA</strong>: Clases como <code>EntidadJpaProducto</code> que mapean las entidades de dominio a la persistencia.</li>
        <li><strong>Configuración</strong>: Configuración de Spring, JPA, etc.</li>
    </ul>
    
    <h3>API REST</h3>
    <ul>
        <li><strong>Controladores</strong>: Clases como <code>ControladorProducto</code> que exponen la funcionalidad como API REST.</li>
        <li><strong>DTOs</strong>: Objetos de transferencia de datos para la comunicación con clientes.</li>
        <li><strong>Documentación</strong>: Anotaciones Swagger para documentar la API.</li>
    </ul>
    
    <h2>5. Diagrama de la Arquitectura</h2>
    <div class="diagram">
┌─────────────────┐      ┌─────────────────┐
│                 │      │                 │
│  CLI (Cliente)  │◄────►│    REST API     │
│                 │      │                 │
└────────┬────────┘      └────────┬────────┘
         │                        │
         │                        │
         │                        ▼
         │               ┌─────────────────┐
         │               │                 │
         └──────────────►│   Aplicación    │
                         │                 │
                         └────────┬────────┘
                                  │
                                  │
                                  ▼
                         ┌─────────────────┐
                         │                 │
                         │     Dominio     │
                         │                 │
                         └────────┬────────┘
                                  │
                                  │
                                  ▼
                         ┌─────────────────┐
                         │                 │
                         │ Infraestructura │
                         │                 │
                         └─────────────────┘
    </div>
    
    <h2>6. Ventajas de la Arquitectura Hexagonal en este Proyecto</h2>
    <ol>
        <li><strong>Mantenibilidad</strong>: La separación clara de responsabilidades facilita el mantenimiento del código.</li>
        <li><strong>Testabilidad</strong>: Es fácil probar cada componente de forma aislada mediante mocks o stubs.</li>
        <li><strong>Flexibilidad</strong>: Se pueden cambiar implementaciones (como el mecanismo de persistencia) sin afectar al dominio.</li>
        <li><strong>Escalabilidad</strong>: La arquitectura modular permite escalar componentes específicos según sea necesario.</li>
        <li><strong>Evolución</strong>: Facilita la evolución del sistema al minimizar el impacto de los cambios.</li>
    </ol>
    
    <h2>7. Conclusión</h2>
    <p>El proyecto de simulación de supermercado implementa la arquitectura hexagonal de manera efectiva, separando claramente las preocupaciones y permitiendo que el dominio se mantenga aislado de los detalles técnicos. Esta arquitectura proporciona una base sólida para el desarrollo, prueba y mantenimiento de la aplicación, y permite que evolucione con el tiempo sin acumular deuda técnica significativa.</p>
    
    <p>La implementación incluye características avanzadas como CQRS, que separa las operaciones de lectura y escritura, y una API REST bien documentada con Swagger. El proyecto demuestra cómo la arquitectura hexagonal puede aplicarse a un sistema de gestión empresarial como un supermercado, proporcionando una solución robusta y mantenible.</p>
    
    <button class="print-button" onclick="window.print()">Imprimir como PDF</button>
</body>
</html>